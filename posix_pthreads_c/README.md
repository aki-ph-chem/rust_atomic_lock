# POSIX Pthreads

- 参考:低レベルプログラミング

## 強弱のメモリモデル

1. 本当に弱いモデル: どんなメモリ操作の並び替えも発生しうる
2. 弱いが、データ依存の順序が保たれる(Arm v7)


```asm
mov rdx,[rbx]
mov rax,[rdx]
```

のような二番目の操作が一番目の操作に依存する場合では順番が保たれる

3. 通常は強い(Intel 64のモデル)

どのストア操作も順番に実行される。しかし、一部のロードの順番は変わる可能性がある。

4. シーケンシャルな一貫性を持つ, 最適化されていないプログラムをデバッガで追いかけるのと同様

## メモリバリア(フェンス)

メモリバリアとはメモリ操作(load,store)の入れ替えを制限する命令である。
以下のようなものがある。

1. 書き込み(store)バリア

このバリアよりも前にあるコードで指定されたストア処理が、
このバリアよりも後で指定されるストア処理よりも前に実行されることを保証する

GNU拡張では

```C
asm volatile(""::: "memory")
```

Intel64では`sfence`を使う

2. 読み込み(ロード)のバリア

同様に、このバリアよりも前にあるコードで指定されたロード処理が、
このバリアよりも後で指定される全てのロード処理よりも前に実行されることを保証する

GNU拡張

```C
asm volatile(""::: "memory")
```

Intel64では`lfence`

3. データ依存バリア

データ依存が考慮される

4. 全体的なメモリバリア

最強のバリアで、この前にあるコードで指定されたメモリの変更が、すべてコミットされることを強制する。
また、この後にある全ての処理が、このバリアよりも前に実行されるように並び替えられることを防ぐ

GNU拡張:

```C
asm volatile("""::: "memory")
```

Intel64では`mfence`を使う

5. acquire操作

共有メモリからの<b>読み込み</b>を実行するとき、それに続くリードとライトがこの操作よりも前に実行されることを防ぐ。

6. release操作

共有メモリからの<b>書き込み</b>を実行するとき、それより前のリードとライトがこの操作よりも前に実行されることを防ぐ。
